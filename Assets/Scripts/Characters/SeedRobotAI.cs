using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using QPathFinder;
using System.Linq;
using QuantumTek.QuantumInventory;

public class SeedRobotAI : MonoBehaviour
{
    PathfindingGoToDestination goToDestination;
    PathFinder pathfinder;
    GameObject seed;
    QI_ItemData seedData;
    public Transform armIK;
    public Transform headBone;
    public Transform seedStoragePoint;
    public Transform armIdlePoint;
    QI_Inventory inventory;

    public enum States
    {
        Roaming,
        TravelTowardsSeed,
        Gathering,
        EndGathering,
        StoreArm
    }

    public States currentState;


    private void Start()
    {
        inventory = GetComponent<QI_Inventory>();
        currentState = States.StoreArm;
        goToDestination = GetComponent<PathfindingGoToDestination>();
        pathfinder = PathFinder.instance;
    }
    private void Update()
    {
        switch (currentState)
        {
            case States.Roaming:
                // check if at node
                if (goToDestination.nodesToDestination.Count != 0)
                {
                    float distanceFromDestination = Vector2.Distance(transform.position, goToDestination.currentDestination);
                    if (distanceFromDestination <= 0.01f)
                    {
                        // check for seed
                        seed = CheckForClosestSeed();
                        if (seed != null)
                        {

                            var destination = (Vector2)seed.transform.position + Vector2.one * .2f;
                            goToDestination.SetDestination(destination); // set new seed destination
                            currentState = States.TravelTowardsSeed;
                        }
                    }
                }


                if (goToDestination.nodesToDestination.Count == 0)
                {
                    SetRandomNodeDestination();
                }
                

                break;

            case States.TravelTowardsSeed:
                float distanceFromSeed = Vector2.Distance(transform.position, goToDestination.currentDestination);
                if (goToDestination.nodesToDestination.Count == 0)
                    currentState = States.Gathering;
                
                    break;


            case States.Gathering:
                StartGatherSeed();
                break;

            case States.EndGathering:
                EndGatherSeed();
                break;
            case States.StoreArm:
                StoreArm();
                break;
            
        }

       
    }

    void StartGatherSeed()
    {
        armIK.position = Vector2.MoveTowards(armIK.position, seed.transform.position, Time.deltaTime * .5f);
        if ((Vector2)armIK.position == (Vector2)seed.transform.position)
        {
            EndGatherSeed();
            StartCoroutine(OpenCloseHead(-70));
            currentState = States.EndGathering;
        }
            

        
    }
    IEnumerator OpenCloseHead(float angle)
    {

        /*Vector3 to = new Vector3(0, 0, angle);
        while(Vector3.Distance(transform.eulerAngles, to) > 0.01f) 
        { 
            transform.eulerAngles = Vector3.Lerp(transform.rotation.eulerAngles, to, Time.deltaTime * .05f);
        }
        transform.eulerAngles = to;*/
        yield return null;
    }

    void EndGatherSeed()
    {
        
        armIK.position = Vector2.MoveTowards(armIK.position, seedStoragePoint.position, Time.deltaTime * .5f);
        if ((Vector2)armIK.position == (Vector2)seedStoragePoint.position)
        {
            if(inventory.AddItem(seedData, 1))
            {
                Destroy(seed);
                seedData = null;
                StartCoroutine(OpenCloseHead(27));
                currentState = States.StoreArm;
            }
            

            
        }


    }

    void StoreArm()
    {
        
        armIK.position = Vector2.MoveTowards(armIK.position, armIdlePoint.position, Time.deltaTime * .5f);
        if ((Vector2)armIK.position == (Vector2)armIdlePoint.position)
        {
            currentState = States.Roaming;
        }
    }
    void SetRandomNodeDestination()
    {
       
        int a = Random.Range(0, pathfinder.graphData.nodes.Count);
        goToDestination.SetDestination(pathfinder.graphData.nodes[a].autoGeneratedID);
    }

    void SetRandomPositionDestination()
    {
        Vector2 dest = Random.insideUnitCircle * 2;
        dest += (Vector2)transform.position;
        goToDestination.SetDestination(dest);
    }

    GameObject CheckForClosestSeed()
    {

        var nearestSeed = FindObjectsOfType<FindableSeed>().Where(t => t != this).OrderBy(t => Vector2.Distance(t.transform.position, transform.position)).FirstOrDefault();
        float dist = Vector2.Distance(nearestSeed.transform.position, transform.position);
        if (dist > 1.5f)
            return null;
        seedData = nearestSeed.seed;
        return nearestSeed.gameObject;
    }

    
}
